# Function to generate input data to fit combined abundance/composition TMB
# model. Designed to model abundance using cpue with tweedie dist.
# or using catch with effort as an offset with negative binomial distribution.
# Catch is data in format similar to dailyCatch_WCVI.rds and comp_wide is 
# generated by clean_comp(). Fac_dat and fac_key are created externally to
# link common factor levels to model outputs.

tmb_dat <- function(catch, comp_wide, fac_dat, fac_key, mod = "nb") {
  # fixed effects model matrices that either include or exclude effort
  sp_t_ch <- paste("~ catchReg + month")
  sp_t_form <- formula(sp_t_ch)
  sp_t_eff_ch <- paste("~ catchReg + month + eff_z + eff_z2")
  sp_t_eff_form <- formula(sp_t_eff_ch)
  
  fix_mm_gsi <- model.matrix(sp_t_form, data = comp_wide)
  fix_mm_c <- if (mod == "tweedie") {
    model.matrix(sp_t_form, data = catch)
  } else {
    model.matrix(sp_t_eff_form, data = catch)
  } 
  
  #helper function to convert factors 
  fct_to_tmb_num <- function(x) {
    as.numeric(as.factor(as.character(x))) - 1
  }
  
  # fit dummy model to speed up tweedie estimatess
  form_dum <- if (mod == "tweedie") {
    formula(paste("log(cpue + 0.0001)", sp_t_ch, sep = ""))
  } else {
    formula(paste("log(catch + 0.0001)", sp_t_eff_ch, sep = ""))
  }
  m1 <- lm(form_dum, data = catch)
  
  # predictive model matrix for abundance based on fac key with the potential for
  # the addition of covariate effects
  mm_pred <- model.matrix(sp_t_eff_form, data = fac_key)
  
  if(!identical(colnames(mm_pred), colnames(fix_mm_c))) {
    warning("Mismatch between estimated and predicted abundance model matrices.")
  }
  
  # observed stock composition
  y_obs <- comp_wide %>% 
    select(-c(id:dummy_id)) %>% 
    as.matrix()
  head(y_obs)
  
  # other parameters
  n_groups <- ncol(y_obs)
  b1_n <- length(coef(m1))
  b2_n <- ncol(mm_pred) * (n_groups - 1) #each par est for each non-ref level
  # vectors of random effects
  fac1k <- fct_to_tmb_num(catch$year)
  fac2k <- fct_to_tmb_num(comp_wide$year)
  nk1 <- length(unique(fac1k))
  nk2 <- length(unique(fac2k))
  
  response <- if (mod == "tweedie") {
    catch$cpue
  } else{
    catch$catch
  }
  
  # combine
  data <- list(
    #abundance data
    y1_i = response,
    X1_ij = fix_mm_c,
    factor1k_i = fac1k,
    nk1 = nk1,
    X1_pred_ij = mm_pred,
    #composition data
    y2_ig = y_obs,
    X2_ij = fix_mm_gsi,
    factor2k_i = fac2k,
    nk2 = nk2,
    m2_all_fac = fac_dat$facs_n,
    m2_fac_key = fac_key$facs_n
  )
  
  parameters = list(
    b1_j = coef(m1) + rnorm(length(coef(m1)), 0, 0.01),
    log_phi = log(1.1),
    logit_p = boot::logit(0.8),
    z1_k = rep(0, length(unique(fac1k))),
    log_sigma_zk1 = log(0.25),
    b2_jg = matrix(0, nrow = ncol(fix_mm_gsi), ncol = (n_groups - 1)), 
    z2_k = rep(0, times = length(unique(fac2k))),
    log_sigma_zk2 = log(0.25)
  )
  
  if(!mod == "tweedie") {
    parameters[["logit_p"]] <- NULL
  }
  
  list(data = data, parameters = parameters)
}
