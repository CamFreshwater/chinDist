## Multinomial model fit
# January 20, 2020
# Fit negative binomial model to catch data
# Similar to fit_negbinomial but glmmTMB and gamm4 replaced with gam
# after issues with convergence

library(mgcv)
library(tidyverse)

dailyCatch <- readRDS(here::here("data", "gsiCatchData", "commTroll",
                                 "dailyCatch_WCVI.rds")) %>% 
  filter(!is.na(cpue)) %>% 
         #remove areas w/ very gappy data
         #area > 100) %>% 
  mutate(area = as.factor(area),
         #condense gappy months necessary for convergence when estimating
         #month:area interactions or random month slopes by area 
         month = as.factor(month),
         month_n = as.numeric(month),
         year = as.factor(year),
         z_eff = as.numeric(scale(boatDays)),
         z_eff2 = z_eff^2) %>% 
  rename(eff = boatDays,
         reg = catchReg)

## Visualize
ggplot(dailyCatch, aes(x = month, y = cpue)) +
  geom_boxplot() +
  ggsidekick::theme_sleek() +
  facet_wrap(~reg)

ggplot(dailyCatch, aes(x = month, y = eff)) +
  geom_boxplot() +
  ggsidekick::theme_sleek() +
  facet_wrap(~area)

ggplot(dailyCatch) +
  geom_point(aes(x = z_eff2, y = catch)) +
  ggsidekick::theme_sleek() +
  facet_wrap(~area, scales = "free")

table(dailyCatch$month, dailyCatch$reg)


## Fit model -------------------------------------------------------------------
# Goal is to make stat area predictions by month, while accounting for effort
# and variation among years. Consider making predictions for NW and SWVI, using
# stat area as a random effect only

# Compare various models
# Model 1 = month intercepts w/ RE intercepts for year and area
nb <- gam(catch ~ s(eff) + month + s(year, bs = "re") + s(area, bs = "re"), 
            data = dailyCatch,
            family = nb)
# Adds a cyclic crs to month
nb_cc <- gam(catch ~ s(z_eff) + s(month_n, bs = "cc") + 
               #s(year, bs = "re") + 
                 s(area, year, bs = "re"), 
            data = dailyCatch,
            family = nb,
            knots = list(month_n = c(1, 12)))
# Adds a tensor product between month and area
nb_cc_tp <- gam(catch ~ s(z_eff) + s(month_n, bs = "cc") + 
                    te(month_n, area, bs = c("cc", "re"), m = 2) + 
                    s(year, bs = "re"), 
               data = dailyCatch,
               family = nb,
               knots = list(month_n = c(1, 12)))
# Uses poisson instead of neg binom
pois_cc_tp <- gam(catch ~ s(z_eff) + s(month_n, bs = "cc") + 
                    te(month_n, area, bs = c("cc", "re"), m = 2) + 
                    s(year, bs = "re"), 
                  data = dailyCatch,
                  family = poisson,
                  knots = list(month_n = c(1, 12)))
# Adds a tensor product between month and area, then nests area within year
nb_cc_tp2 <- gam(catch ~ s(z_eff) + s(month_n, bs = "cc") + 
                   s(month_n, area, bs = "fs", xt = list(bs = "cc")) +
                   s(area, year, bs = "re"), 
                 data = dailyCatch,
                 family = nb,
                 knots = list(month_n = c(1, 12)))

# Adds a tensor product between month, area and year
nb_cc_tp3 <- gam(catch ~ s(z_eff) + s(month_n, bs = "cc") + 
                  t2(month_n, area, year, bs = c("cc", "re", "re"), m = 2,
                     full = TRUE), 
                data = dailyCatch,
                family = nb,
                knots = list(month_n = c(1, 12)))

nb_cc_tp3_fix <- gam(catch ~ s(z_eff, k = 20) + s(month_n, bs = "cc", k = 10) + 
                   t2(month_n, area, year, bs = c("cc", "re", "re"), k = 10, m = 2,
                      full = TRUE), 
                 data = dailyCatch,
                 family = nb,
                 knots = list(month_n = c(1, 12)))




AIC(nb); AIC(nb_cc); AIC(nb_cc_tp); AIC(nb_cc_tp2); AIC(nb_cc_tp3); AIC(nb_cc_tp3_fix)
# poisson favored but strong evidence of overdisp so stick w/ neg binomial

gam.check(nb_cc_tp3)
k.check(nb_cc_tp2)
k.check(nb_cc_tp3_fix)
# some evidence that default k is insufficient



gam.vcomp(nb_cc_tp3)


## Check for overdispersion
# root_pois <- countreg::rootogram(pois_cc_tp, style = "hanging", plot = TRUE)
# root_nb   <- countreg::rootogram(nb_cc_tp, style = "hanging", plot = TRUE)
# 
# sum(residuals(pois_cc_tp, type = "pearson")^2) / df.residual(pois_cc_tp)
# sum(residuals(nb_cc_tp, type = "pearson")^2) / df.residual(nb_cc_tp)
# definitely necessary to use negative binomial



## Check model -----------------------------------------------------------------

plot_fits(nb_cc_tp3, dat = dailyCatch, exclude = FALSE, y = "resid")
plot_fits(nb_cc_tp3, dat = dailyCatch, exclude = TRUE, y = "obs")

plot_fits <- function(mod, dat, exclude = TRUE, y = "resid", nbin = TRUE) {
  fit_dat <- broom.mixed::augment(mod, data = dat)
  
  if (exclude == FALSE) {
    if (y == "resid") {
      q <- ggplot(fit_dat, aes(.fitted, .resid))  
    }
    if (y == "obs") {
      q <- ggplot(fit_dat, aes(.fitted, catch))  
    }
    p <- q + geom_point(aes(colour = area)) +
      # geom_smooth() +
      ggsidekick::theme_sleek() +
      facet_wrap(~month, scales = "free")
  }
  
  if (exclude == TRUE) {
    yy <- unique(dat$year)[1]
    aa <- unique(dat$area)[1]
    
    newd <- transform(dat, year = yy)
                      #, area = aa)
    pred <- predict(mod, newd, exclude = c("s(year)"))
    #transform predictions if using nbinom
    if(nbin == TRUE) {
      pred <- exp(pred)
    }
    fit_dat$.fitted0 <- pred
    fit_dat$.resid0 <- fit_dat$catch - fit_dat$.fitted0
    
    if (y == "resid") {
      q <- ggplot(fit_dat, aes(.fitted0, .resid0))  
    }
    if (y == "obs") {
      q <- ggplot(fit_dat, aes(.fitted0, catch))  
    }
    p <- q + 
      geom_point(aes(colour = area)) +
      # geom_smooth() +
      ggsidekick::theme_sleek() +
      facet_wrap(~month, scales = "free")
  }
  return(p)
}




